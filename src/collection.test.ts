import { Rhum } from "../testing_deps.ts";
import identity from "./utils/identity.ts";

import countBy from "./collection/countBy.ts";
import count from "./collection/count.ts";
import flatMapDeep from "./collection/flatMapDeep.ts";
import flatMapDepth from "./collection/flatMapDepth.ts";
import groupBy from "./collection/groupBy.ts";
import keyBy from "./collection/keyBy.ts";
import sortBy from "./collection/sortBy.ts";
import shuffle from "./collection/shuffle.ts";
import sample from "./collection/sample.ts";
import sampleOne from "./collection/sampleOne.ts";

Rhum.testPlan("collection/*", () => {
  Rhum.testSuite("countBy()", () => {
    Rhum.testCase(
      "Should create an object composed of keys generated by running each element of collection through the iteratee",
      () => {
        Rhum.asserts.assertEquals(countBy(Math.floor, [6.1, 4.2, 6.3]), {
          "4": 1,
          "6": 2,
        });
        Rhum.asserts.assertEquals(
          countBy((elem: string) => elem.length, ["one", "two", "three"]),
          { "3": 2, "5": 1 }
        );
        Rhum.asserts.assertEquals(
          countBy(identity, ["foo", "bar", "foo", "bar", "foo", "baz"]),
          { bar: 2, baz: 1, foo: 3 }
        );
      }
    );
  });
  Rhum.testSuite("count()", () => {
    Rhum.testCase(
      "Should create an object counting the occurance of each element of collection",
      () => {
        Rhum.asserts.assertEquals(
          count(["foo", "bar", "foo", "bar", "foo", "baz"]),
          { bar: 2, baz: 1, foo: 3 }
        );
      }
    );
  });
  Rhum.testSuite("flatMapDeep()", () => {
    Rhum.testCase("should created a deeply flattened flatmap", () => {
      Rhum.asserts.assertEquals(
        flatMapDeep((x: number) => [[x * 2]], [1, 2, 3, 4]),
        [2, 4, 6, 8]
      );
    });
  });
  Rhum.testSuite("flatMapDepth()", () => {
    Rhum.testCase(
      "should created a flattened flatmap only to a certain level",
      () => {
        Rhum.asserts.assertEquals(
          flatMapDepth((n: any) => [[[n, n]]], [1, 2], 2),
          [
            [1, 1],
            [2, 2],
          ]
        );
      }
    );
  });
  Rhum.testSuite("groupBy()", () => {
    Rhum.testCase(
      "create an object composed of keys generated from the collection run through an iteratee",
      () => {
        Rhum.asserts.assertEquals(groupBy(Math.floor, [6.1, 4.2, 6.3]), {
          "4": [4.2],
          "6": [6.1, 6.3],
        });
        Rhum.asserts.assertEquals(
          groupBy((n: number): string => (n % 2 === 0 ? "even" : "odd"), [
            1,
            2,
            3,
            4,
            5,
          ]),
          {
            even: [2, 4],
            odd: [1, 3, 5],
          }
        );
      }
    );
  });
  Rhum.testSuite("keyBy()", () => {
    Rhum.testCase(
      "Creates an object composed of keys generated from the results of running each element of collection thru iteratee.",
      () => {
        interface Button {
          dir: string;
          code: number;
        }
        const testArray: Button[] = [
          { dir: "left", code: 97 },
          { dir: "right", code: 100 },
        ];
        Rhum.asserts.assertEquals(
          keyBy((x: Button) => String.fromCharCode(x.code), testArray),
          {
            a: { dir: "left", code: 97 },
            d: { dir: "right", code: 100 },
          }
        );
        Rhum.asserts.assertEquals(keyBy("dir", testArray), {
          left: { dir: "left", code: 97 },
          right: { dir: "right", code: 100 },
        });
      }
    );
  });
  Rhum.testSuite("sortBy()", () => {
    Rhum.testCase(
      "sorts the order of the iteratees based on the criteria provided",
      () => {
        type TestType = { user: string; age: number };
        const testArray: TestType[] = [
          { user: "fred", age: 48 },
          { user: "barney", age: 34 },
          { user: "fred", age: 40 },
          { user: "barney", age: 36 },
        ];
        Rhum.asserts.assertEquals(
          sortBy(
            testArray,
            (a: TestType, b: TestType): number => a.user.localeCompare(b.user),
            (a: TestType, b: TestType): number => a.age - b.age
          ),
          [
            { user: "barney", age: 34 },
            { user: "barney", age: 36 },
            { user: "fred", age: 40 },
            { user: "fred", age: 48 },
          ]
        );
        Rhum.asserts.assertEquals(
          sortBy(
            testArray,
            (a: TestType, b: TestType): number => a.user.localeCompare(b.user),
            (a: TestType, b: TestType): number => b.age - a.age
          ),
          [
            { user: "barney", age: 36 },
            { user: "barney", age: 34 },
            { user: "fred", age: 48 },
            { user: "fred", age: 40 },
          ]
        );
      }
    );
  });
  Rhum.testSuite("sample()", () => {
    Rhum.testCase("gets N unique elements of an array", () => {
      const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const sampled1 = sample(arr, 3);
      Rhum.asserts.assertArrayContains(arr, sampled1);
      Rhum.asserts.assertStrictEquals(sampled1.length, 3);
      const sampled2 = sample(arr, 5);
      Rhum.asserts.assertArrayContains(arr, sampled2);
      Rhum.asserts.assertStrictEquals(sampled2.length, 5);
    });
  });
  Rhum.testSuite("sampleOne()", () => {
    Rhum.testCase("returns one random element of an array", () => {
      const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const one = sampleOne(arr);
      Rhum.asserts.assertArrayContains(arr, one);
      Rhum.asserts.assertEquals(Array.isArray(one), false);
    });
  });
  Rhum.testSuite("shuffle()", () => {
    Rhum.testCase("shuffles an array", () => {
      const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const shuffled = shuffle(arr);
      Rhum.asserts.assertArrayContains(shuffled, arr);
      Rhum.asserts.assertNotEquals(shuffled, arr); // this test may fail, the chances of that however, are 10!:1 (3.6M/1);
    });
  });
});

Rhum.run();
